#include <iostream>
#include <vector>
#include <algorithm>
#include "Polynomial.h"
#include "Parameters.h"
#include <math.h>
#include <sstream>
#include <bitset>
#include "Keys.h"

Polynomial encryptPoly(Polynomial toEncrypt, Polynomial publicKey, Parameters p);
Polynomial decryptPoly(Polynomial toDecrypt, Polynomial privateKeyF, Polynomial privateKeyFp, Parameters p);
vector<Polynomial> encryptString(string toEncrypt, Polynomial publicKey, Parameters p);
string decryptString(vector<Polynomial> toDecrypt, Polynomial privateKeyF, Polynomial privateKeyFp, Parameters p);
vector<Polynomial> stringToBinPolys(string in, int n);
string binPolysToString(vector<Polynomial> in, int n);
string polysToBinaryString(vector<Polynomial> in, int n);

using namespace std;
int main()
{
    Parameters params(3,2,5,32,11);
    Keys keys(params);
    cout << keys.toString() << endl;
    // int fArr[11] = {-1, 1 ,1, 0, -1, 0, 1, 0, 0, 1 , -1};
    // int gArr[11] = {-1, 0, 1, 1, 0, 1, 0, 0, -1, 0, -1};
    // Polynomial f(fArr, params.getN());
    // Polynomial g(gArr, params.getN());
    // cout << "F(X): " << f.toString() << endl;
    // cout << "G(X): " << g.toString() << endl;
    // Polynomial invertedMod2 = invertPolyMod2(f, params.getN());
    // Polynomial invertedMod3 = invertPolyMod3(f, params.getN());
    // Polynomial invertedMod32 = invertPolyModPrimePower(f, invertedMod2, params.getN(), params.getX(), params.getR());
    // cout << "FP(X): " << invertedMod3.toString() << endl;
    // cout << "FQ(X): " << invertedMod32.toString() << endl;
    // int arr3[1] = {3};
    // Polynomial p3(arr3,1);
    // Polynomial publicKey = ((p3*invertedMod32)*g).reduceExpMod(params.getN());
    // publicKey.reduceCoeffMod(params.getQ());
    // cout << "H(X): " << publicKey.toString() << endl;

    // int mArr[] = {-1,0,0,1,-1,0,0,0,-1,1,1};
    // Polynomial message(mArr, params.getN());
    // Polynomial encrypted = encryptPoly(message, keys.getPublicKey(), params);
    // Polynomial decrypted = decryptPoly(encrypted, keys.getPrivateKeyF(), keys.getPrivateKeyFp(), params);

    string in = "Hello world, how are you?";
    vector<Polynomial> enc = encryptString(in, keys.getPublicKey(), params);
    cout << "Encrypted" << polysToBinaryString(enc, params.getN()) << endl;
    string dec = decryptString(enc, keys.getPrivateKeyF(), keys.getPrivateKeyFp(), params);
    cout << dec << endl;
}

/* 
    Function to encrypt a given polynomial with a recipients public key

    Encrypted = r * publicKey + toEncypt (mod q) where r is a poly with small coeffs

    @input toEncrypt - Polynomial to encrypt
    @input publicKey - Public key of recipient for NTRU encryption
    @output Polynomial encrypted with public key


*/
Polynomial encryptPoly(Polynomial toEncrypt, Polynomial publicKey, Parameters p)
{
    int rArr[] = {-1,0,1,1,1,-1,0,-1};
    Polynomial r(rArr,8);
    Polynomial rPubKey = (r * publicKey).reduceExpMod(p.getN());
    Polynomial encrypted = rPubKey + toEncrypt;
    encrypted.reduceCoeffMod(p.getQ());
    return encrypted;
}

/* 
    Function to decrypt a given encrypted polynomial

    Procedure:
        a = privateKeyF * toDecrypt (mod q)
        b = a (mod p) = privateKeyF * message (modP)
        c = b * privateKeyFq = (privateKeyF * privateKeyFq) * message = message (mod p)

    @input toDecrypt - Polynomial to decrypt, encrypted with users public key
    @input privateKeyF - Private Key F generated by user
    @input privateKeyFp - Inverse of private key F (mod p)
    @output Message polynomial


*/
Polynomial decryptPoly(Polynomial toDecrypt, Polynomial privateKeyF, Polynomial privateKeyFp, Parameters p)
{
    Polynomial a = (privateKeyF * toDecrypt).reduceExpMod(p.getN());
    a.reduceCoeffMidMod(p.getQ());
    a.reduceCoeffMidMod(p.getP());
    Polynomial c = (a * privateKeyFp).reduceExpMod(p.getN());
    c.reduceCoeffMidMod(p.getP());
    return c;
}

//Convers a string to a vector of degree N polys with coeffs in {0,1}
vector<Polynomial> stringToBinPolys(string in, int n)
{
    vector<Polynomial> polyVec;
    string binary = "";
    for (int i = 0; i < in.length(); i++)
    {
        binary += bitset<8>(in[i]).to_string();
    }
    int numBits = in.length() * 8;
    int numPolys = ceil((float)numBits / n);
    for (int i = 0; i < numPolys; i++)
    {
        int polyArr[n] = {};
        for (int j = 0; j < n; j++)
        {
            int index = i*n + j;
            if (index < numBits)
            {
                polyArr[j] = binary[i*n + j] - 48;
            }
            else
            {
                polyArr[j] = 0;
            }
        }
        Polynomial poly(polyArr, n);
        polyVec.push_back(poly);

    }
    return polyVec;
}

//Convers a vector of degree N polys with coeffs in {0,1} to a string
string binPolysToString(vector<Polynomial> in, int n)

{
    string bitStr = "";
    string out = "";
    for (Polynomial poly : in)
    {
        int length = poly.getLength();
        for (int i = 0; i < n; i++)
        {
            if (i < length)
            {
                bitStr += (poly.getCoeff(i) + 48); 
            } 
            else
            {
                bitStr += '0';
            }
                   
        }
    }
    stringstream stream(bitStr);
    while(stream.good())
    {
        bitset<8> bits;
        stream >> bits;
        char c = char(bits.to_ulong());
        out += c;
    }
    return out;
}

//Convers a vector of degree N polys to a binary string
string polysToBinaryString(vector<Polynomial> in, int n)
{
    string bitStr = "";
    for (Polynomial poly : in)
    {
        int length = poly.getLength();
        for (int i = 0; i < n; i++)
        {
            if (i < length)
            {
                bitset<8>bit(poly.getCoeff(i));
                bitStr += bit.to_string();
            } 
            else
            {
                bitStr += '0';
            }
                   
        }
    }
    return bitStr;
}

//Converts a string into multiple polynomials of degree N, then encrypts with public key
vector<Polynomial> encryptString(string toEncrypt, Polynomial publicKey, Parameters param)
{
    vector<Polynomial> plainPolys = stringToBinPolys(toEncrypt, param.getN());
    vector<Polynomial> encryptedPolys;
    for (Polynomial p : plainPolys)
    {
        Polynomial enc = encryptPoly(p, publicKey, param);
        encryptedPolys.push_back(enc);
    }
    return encryptedPolys;
}
//Decrypts multiple polynomials of fegree N with private key and returns a string
string decryptString(vector<Polynomial> toDecrypt, Polynomial privateKeyF, Polynomial privateKeyFp, Parameters param)
{
    vector<Polynomial> plainPolys;
    for (Polynomial p : toDecrypt)
    {
        Polynomial dec = decryptPoly(p, privateKeyF, privateKeyFp, param);
        plainPolys.push_back(dec);
    }
    string decrypted = binPolysToString(plainPolys, param.getN());
    return decrypted;    
}